Scoped properties configuration library
=======================================

This project provides a lightweight and flexible library for parsing configuration
files built of properties (key/value pairs) which may reside inside "scopes",
that is blocks of configuration with assigned name and an optional type. Scopes
may constitute hierarchical nesting tree of an arbitrary depth.

The library provides small but flexible set of API for accessing properties in
a configuration file. There is possible to access a property located inside a
specific scope when its location (path) is known OR to discover a configuration
file structure by iterating over properties/scopes located on the same level of
depth.

The library is inspired by:
 - Microsoft INI files API: GetPrivateProfileXXX() family of functions with
   their simplicity of usage, sections and basic iteration functionality.
 - JSON serialization format with its C-based grammar and elaborated objects
   definitions.

Configuration file format
-------------------------

"One word from Chairman Mao is worth ten thousand from others" --Lin Biao
The same is true with a good example:

    # A comment starts with '#' up to the end of line.
    # The 2 properties below are located on the depth level 0 (global scope)
    prop1 = value

    # Apostrophes required in the property name to avoid parsing problem.
    # A property value finishes at the end of a line or at a semicolon (unless
    # NO_SEMICOL_ENDS_VAL had been defined during library compilation).
    "property 2" = some other value;

    # Scope with a type and name
    scope_type scope_name
    {
        # Level depth 1

        # 2 properties w/o their values (defined in the same line)
        a; b=;

        # Scope w/o a type. If no apostrophes had been used, the scope name
        # would be "name" with type "scope".
        "scope name"
        {
            # Level depth 2

            c = property "c" value \
                with line \
                continuation;

            # Property contains escaped characters: semicolon, LF and space
            d = \;abc\n\x20\\
        }

        # Property names may contain arbitrary characters. Escaped characters
        # may be used. In this example apostrophes are required since '{', '}'
        # are parser's reserved tokens (marking start/end of a scope).
        "{\tprop name w/o a value\t}";

        # Scope "scope name" continuation (with empty body).
        "scope name" {}
    }

In this example there have been defined several properties (in the global scope)
and inside 2 scopes. The library provides file-path-based method of addressing
properties. Here:

    prop1 OR /prop1 -> "prop1" property path
    /scope_type:scope_name/a -> "a" inside "scope_name" of a type "scope_type"
    /scope_type:scope_name/scope name/c -> "c" property

API specification
-----------------

The library provides two types of API:
 - Low level parser API with header: inc/sp_props/parser.h,
 - Hight level functional API with header: inc/sp_props/props.h.

The first type of API defines low level, parser specific functionality and is
not intended to be used unless you need a direct cooperation with the parser for
some specific reason. The interface defines set of callbacks which allow an
application to be informed about reducing some specific grammar rules.

The second type of API constitutes the proper interface (its implementation
bases on the low level parser API). The API allows addressing properties inside
their hosting scopes AND to discover a configuration structure by iterating over
its content.

NOTE: Basically, the API treats properties values as strings built of arbitrary
characters which are not interpreted: sp_get_prop(). Moreover, there have been
provided 2 simple functions (referencing sp_get_prop()) to interpret strings as
integers and enumerations, namely: sp_get_prop_int(), sp_get_prop_enum(). Tables
and lists may be easily emulated by dedicated scopes and iterations over their
content.

Refer to the mentioned header files for complete API specification and the unit
test ut/sptest.c for an usage example.

Compilation
-----------

Prerequisites:
 - GNU make,
 - bison parser generator of version 3 or higher (only in case of regenerating
   parser.c grammar definition file).

Compilation:

  make

produces static library "libsprops.a" which may be linked into an application.

Unit tests are contained in ut/ directory.

Notes
-----

 - The library uses standard C library interface and shall be ported with a
   little effort for any conforming platforms.
 - Memory allocation is performed ONLY by the generated grammar parser code for
   reducing read grammar rules. The bison parser allows a flexible way for
   configuring such allocations (e.g. via stack alloc() or heap malloc())
   which may be useful for porting on some constrained embedded platforms.
   See the bison parser generator documentation for more details.
 - The API is fully re-entrant. No global variables are used during parsing.

TODO
----

 - Current version of the library provides read-only/get access to the
   configuration. Write/set functionality is intended to be added.
 - Conditionally compiled POSIX threads based synchronization to be added (
   possibly Windows version too). Conditional support is justified by portability
   of the library for wide range of platforms where threads synchronization is
   not possible or needed.

License
-------
2 clause BSD license. See LICENSE file for details.
