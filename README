Scoped properties configuration library
=======================================

This project provides a lightweight and flexible library for parsing configuration
files built of properties (key/value pairs) which may reside inside "scopes",
that is blocks of configuration with assigned name and an optional type. Scopes
may constitute hierarchical nesting tree of an arbitrary depth.

The library API consists of small but powerful set of C functions for accessing
properties in a configuration file. There is possible to access a property
located inside a specific scope when its location (path) is known OR to discover
a configuration file structure by iterating over properties/scopes located on
the same level of depth.

Full support for UNIX (LF), Windows (CR/LF) and Legacy Mac (CR) end-of-line
markers.

The library is inspired by:
 - Microsoft INI files API: GetPrivateProfileXXX() family of functions with
   their simplicity of usage, sections and basic iteration functionality.
 - JSON serialization format with its C-based grammar and elaborated objects
   definitions.

Configuration file format
-------------------------

"One word from Chairman Mao is worth ten thousand from others" --Lin Biao
The same is true with a good example:

    # A comment starts with '#' up to the end of line.
    # The 2 properties below are located on the depth level 0 (global scope)
    prop1 = value

    # Quotation marks required in the property name to avoid parsing problem.
    # A property value finishes at the end of a line or at a semicolon (unless
    # NO_SEMICOL_ENDS_VAL had been defined during library compilation).
    "property 2" = some other value;

    # Scope with a type and name
    scope_type scope_name
    {
        # Level depth 1

        # 2 properties w/o their values (defined in the same line)
        a; b=;

        # Scope w/o a type. If no quotation marks had been used, the scope name
        # would be "name" with type "scope".
        "scope name"
        {
            # Level depth 2

            c = property "c" value \
                with line \
                continuation;

            # Property contains escaped characters: semicolon (0x3b), LF (\n),
            # space (\x20) and backslash (\\)
            d = \x3babc\n\x20\\
        }

        # Property names may contain arbitrary characters. Escaped characters
        # may be used. In this example quotation marks are required since '{',
        # '}' are parser's reserved tokens (marking start/end of a scope).
        "{\tprop name w/o a value\t}";

        # Scope "scope name" continuation (with empty body).
        "scope name" {}
    }

In this example there have been defined several properties (in the global scope
and 2 nested scopes). The library provides file-path-based method of addressing
properties. Here:

    prop1 OR /prop1 -> "prop1" property path
    /scope_type:scope_name/a -> "a" inside "scope_name" of a type "scope_type"
    /scope_type:scope_name/scope name/c -> "c" property

API specification
-----------------

The library provides two types of API:
 - Low level parser API with header: inc/sp_props/parser.h,
 - High level functional API with header: inc/sp_props/props.h.

The first type of API defines low level, parser specific functionality and is
not intended to be used unless, for some reason, you need a direct cooperation
with the parser. The interface defines set of callbacks which allow an
application to be informed about reducing some specific grammar rules.

The second type of API constitutes the proper interface (its implementation
bases on the low level parser API). The API allows addressing properties inside
their hosting scopes AND to discover a configuration structure by iterating over
its content.

NOTE: Basically, the API treats properties values as strings built of arbitrary
characters which are not interpreted: sp_get_prop(). For the convenience there
have been provided 3 simple functions (referencing sp_get_prop()) to interpret
strings as integers, floats and enumerations, namely: sp_get_prop_int(),
sp_get_prop_float(), sp_get_prop_enum(). Lists may be easily emulated by iterating
over dedicated scopes content.

Refer to the mentioned header files for complete API specification and the unit
tests located in ut/ directory for an usage example.

Compilation
-----------

Prerequisites:
 - GNU make,
 - bison parser generator of version 3 or higher (only in case of regenerating
   parser.c grammar definition file).

Compilation:

  make

produces static library "libsprops.a" which may be linked into an application.

Unit tests are contained in ut/ directory.

Notes
-----

 - The library uses standard C library interface and shall be ported with a
   little effort for any conforming platforms.
 - Memory allocation is performed ONLY by the generated grammar parser code for
   reducing read grammar rules. The bison parser allows a flexible way for
   configuring such allocations (e.g. via stack alloca() or heap malloc())
   which may be useful for porting to some constrained embedded platforms.
   See the bison parser generator documentation for more details.
 - The API is fully re-entrant. No global variables are used during the parsing
   process.
 - The library is thread safe in terms of all library objects except passed
   input file-objects (that is file handles for get-access and physical files
   for set-access). Since there is no effective way to ensure such file-objects
   synchronization on the library level, the application is responsible to handle
   this issue. This may be done via standard thread synchronization approach or
   by other means, e.g. if many threads get-access a single configuration file,
   each of the threads may use its own read-only file handle to access the file
   in a thread safe way (such approach is much more effective than a classical
   mutext usage).

TODO
----

 - Current version of the library provides get-access to the configuration.
   Set-access functionality is intended to be added.

License
-------
2 clause BSD license. See LICENSE file for details.
